#include <iostream>
#include <thread>
#include <chrono>
#include <vector>
#include <bits/stdc++.h> 
//#include <boost/coroutine2/all.hpp>

class Chrono 
{
public:
    Chrono() = default;
    ~Chrono() = default;
    inline void start()
    {
        m_start = std::chrono::high_resolution_clock::now();
    }
    inline void stop()
    {
        m_end = std::chrono::high_resolution_clock::now();
    }
    inline void print_duration(std::string message = "")
    {
        std::cout << message << std::chrono::duration_cast<std::chrono::microseconds>(m_end - m_start).count() << " microsec\n";
    }
    inline std::chrono::microseconds stop_print_return_duration(std::string message = "")
    {
        stop();
        print_duration(message);
        return std::chrono::duration_cast<std::chrono::microseconds>(m_end - m_start);
    }
private:
    std::chrono::time_point<std::chrono::high_resolution_clock> m_start;
    std::chrono::time_point<std::chrono::high_resolution_clock> m_end;
};

class Executable
{
public:
    Executable() = default;
    ~Executable() = default;
    void long_function();
    void long_function_repeat_singleThread()
    {
        for (int i = 0; i < 10; i++)
            long_function();
    }
    void long_function_repeat_multiThread()
    {
        std::vector<std::jthread> threads;

        for (int i = 0; i < 10; i++)
            threads.push_back(std::jthread(&Executable::long_function, this));
    }
    /*void long_function_repeat_multiThread_coroutine(boost::coroutines2::coroutine<void>::push_type& yield)
    {
        for (int i = 0; i < 10; i++)
        {
            long_function();
            yield();
        }
    }*/
    
};

void Executable::long_function()
{
    std::vector<int> v;
    for (int i = 0; i < 10000; i++)
    {
        v.push_back(i);
        std::sort(v.begin(), v.end());
    }
}

/*std::chrono::microseconds coroutineProcess(Executable& ex)
{
	boost::coroutines2::coroutine<void>::pull_type coro([&](boost::coroutines2::coroutine<void>::push_type& yield)
    {
        ex.long_function_repeat_multiThread_coroutine(yield);
    });
    while (coro)
    {
        coro();
    }
}*/

int main()
{
    Executable ex;
    Chrono chrono;

    // Single Thread
    chrono.start();
    ex.long_function_repeat_singleThread();
    auto duration1 = chrono.stop_print_return_duration("Single Thread: ");

    // Multi Thread
    chrono.start();
    ex.long_function_repeat_multiThread();
    auto duration2 = chrono.stop_print_return_duration("Multi Thread: ");
    
    // Multi Thread with coroutine
    chrono.start();
	/*coroutineProcess(ex);*/
	auto duration3 = chrono.stop_print_return_duration("Multi Thread with coroutine: ");
    return 0;
}
